 # Dijkstra (다익스트라)
 > + 그래프에서 한 노드에서 다른 노드들까지의 ``최단경로``를 구하는 알고리즘      
 > + 다이나믹 프로그래밍을 활용한 대표적인 ``최단경로탐색 알고리즘`` -> 현재까지 알고 있던 최단 경로를 계속 갱신      
 > + weigt가 **음수인 것은 허용되지 않는다**.    
 > + **cycle은 허용**된다.         
 > + 최단경로를 구하는 알고리즘에는 **벨만-포드, 프로디드 워샬 알고리즘**도 존재         
 
 ## 순차탐색
 > 방문하지 않은 노드 중 거리값이 가장 작은 노드를 선택해 다음 탐색 노드를 선택
 
 ## 작동 과정
 1. 출발 노드와 도착 노드를 설정
 2. 최단거리를 저장하는 배열을 초기화 (무한으로)
 3. 현재 위치한 노드의 인접 노드 중 방문하지 않은 노드를 구별,
    방문하지 않은 노드 중 거리가 짧은 노드를 선택하고 방문 처리
 4. 해당 노드를 거쳐 다른 노드로 가는 weight를 계산해 최단거리를 업데이트
 5. 3과 4번 과정 반복

예시)       
![image](https://user-images.githubusercontent.com/104772331/211724409-80bf614e-6e6b-4966-9b04-065f6a47c064.png)     
-> 무한으로 초기화 , 출발노드 : 1 , 도착노드 : 6
![image](https://user-images.githubusercontent.com/104772331/211724533-595fe184-f8ab-4ca7-9941-e851e24129a8.png)        
-> 출발노드를 0으로 초기화    
![image](https://user-images.githubusercontent.com/104772331/211724579-90cd7886-a711-4a28-9336-034bf92cc674.png)           
-> 인접한 노드 중 방문하지 않은 노드의 거리값을 비교해 업데이트      
-> 방문하지 않은 노드 중 거리값이 작은 노드를 선택 (4번 노드 선택)          
-> 1 노드는 방문처리               
![image](https://user-images.githubusercontent.com/104772331/211724993-2aa2aee4-4aa6-4656-ae03-c634b3a3a0f4.png)       
-> 4번과 연결된 2,5번까지 오는 거리 계산 후 비교            
-> 방문하지 않은 노드 중 거리값이 작은 노드 선택(2번이나 5번 노드 선택)   
-> 이후는 똑같은 과정 반복            
<img src = "https://user-images.githubusercontent.com/104772331/211851517-45ab8bbc-6e81-429a-9cd7-bea0605c9a5b.png" width="700" height="600"/> 
-> 최종 결과값         

 ## 우선순위 큐(priority Queue)를 활용
 > + 순차 탐색을 사용하는 경우 시간이 오래 걸릴 수 있는 점을 개선        
 > + 최소 거리 값을 우선순위로 가지는 ``priority queue``를 활용.          
 > + ``-``를 붙여 가까운 거리가 가장 앞에 오도록 한다.  
 > + 시작노드로부터 **가장 가까운 노드가 우선순위**가 된다.    
 > + 방문 여부를 기록할 필요가 없다.      
 
 ## 작동 과정 
 1. 최단 거리를 초기화(무한으로)
 2. 출발 노드를 설정
 3. 최소거리가 되면 priority queue에 저장하면서 지금까지의 거리와 비교하면서 업데이트
 4. priority queue가 빌 때까지 반복

예시)        
<img src = "https://user-images.githubusercontent.com/104772331/211726622-72ab7a34-66bf-4971-9566-2feaf04bfe70.png" width="600" height="600"/>     
-> 시작노드의 거리를 업데이트                
-> priority queue에 저장       
![image](https://user-images.githubusercontent.com/104772331/211726727-b4303097-bed5-4ff5-b8c1-9527f3305880.png)          
-> queue에서 꺼내어 인접한 노드를 봄                
-> 거리값이 작으면 업데이트하고, 큐에 저장        
![image](https://user-images.githubusercontent.com/104772331/211727108-1a34a30e-a8d4-4fda-afba-74241c43863a.png)           
-> 노드를 꺼내서 인접 노드를 조사           
-> 위에서와 같이 거리값이 작으면 업데이트하고, 큐에 저장            
-> 4에서 2로 가는 경우 3이기 때문에 업데이트를 하지 않고, 큐에도 저장하지 않음.             
![image](https://user-images.githubusercontent.com/104772331/211727680-3c26dcb6-c087-461f-8f8e-ecd5d760425e.png)
![image](https://user-images.githubusercontent.com/104772331/211727713-e7b64de6-6f8b-4ca0-b921-c6de3d424061.png)
![image](https://user-images.githubusercontent.com/104772331/211727734-895293b1-cf19-4803-b8dc-a3d08bc3d556.png)
![image](https://user-images.githubusercontent.com/104772331/211727766-4c75eb8a-bc37-4fb1-b15e-0b462db9a428.png)

## 요약
------
> - 시작점을 정하면, 그곳에서 다른 노드들까지의 최단 경로들을 구할 수 있다.     
> - ``-`` 를 붙여 음수로 만들어 작은 것이 가장 앞으로 오도록 한다. (greater <int>를 활요하면 시간이 더 오래걸린다.)
-----------------
 
+ 참고블로그     
 <https://velog.io/@717lumos/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EB%8B%A4%EC%9D%B5%EC%8A%A4%ED%8A%B8%EB%9D%BCDijkstra-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98>
  
## 1753번 문제 <최단경로>
> + 방향그래프가 주어지면, 주어진 시작점에서 다른 모든 정점으로의 최단경로를 구하는 프로그램    
> + vertex, edge , start vertex가 주어지면 최단경로들을 출력
  
### 풀이과정
  1. 입력받는 edge들을 시작 vertex를 index로 하고 끝나는 vertex와 weight를 pair로 저장
  2. 서로 vertex간의 거리를 무한으로 초기화
  3. 시작 vertex를 0으로 설정하고 priority queue에 거리인 0과 자신의 번호를 저장
  4. priority queue에서 꺼내면서 현재 vertex의 방향이 향하는 vertex들의 weight와 현재 노드가 가지는 경로와     
  방향이 향한 vertex의 경로길이를 비교하면서 작다면 업데이트 후, priority queue에 저장   
  5. priority queue가 없어질때까지 반복
  6. 계산한 거리를 출력
  

## 1504번<특정한 최단경로>
> + 방향성이 없는 그래프
> + 1번부터 N번 정점으로 최단 거리로 이동 
> + 임의로 주어지는 두 edge를 반드시 통과
> + 한번 이동했던 vertex와 edge 이용가능
> + 이 조건을 만족하는 최단 경로 프로그램을 작성
  
### 풀이과정
  1. 입력받는 시작 vertex 와 도착 vertex와 weight를 저장(양방향이라 두 방향 모두 저장)
  2. 시작점에서 끝점을 입력받으면 끝점까지의 최단경로를 반환
  3. 임의의 두 edge를 v1,v2라고 하면, 시작점 -> v1 ->v2-> 끝점까지의 거리와     
  시작점 -> v2 -> v1 -> 끝점까지의 거리를 비교해 최단경로를 출력
  4. edge가 없거나 둘 사이의 경로, 시작점에서 두점까지의 경로, 두점에서 끝점까지의 경로가 없으면 -1출력
  
 ## 10282번 <해킹>
> + 서로에 의존하는 컴퓨터들이 전염
> + a가 b에 의존한다면, b가 감염되면 일정시간 후에 a도 감염
> + T-> 테스트 수 100개가 최대컴퓨터 수 N, 의존성 개수 D, 해킹당한 컴퓨터 번호 C (1 ≤ n ≤ 10,000, 1 ≤ d ≤ 100,000, 1 ≤ c ≤ n). 
> + a가 컴퓨터 b를 의존하며, 컴퓨터 b가 감염되면 s초 후 컴퓨터 a도 감염됨을 뜻한다.
> + 테스트 케이스마다 한 줄에 걸쳐 총 감염되는 컴퓨터 수, 마지막 컴퓨터가 감염되기까지 걸리는 시간을 공백으로 구분지어 출력
  
  ### 풀이과정
  1. 해킹당한 컴퓨터를 시작점으로 다른 vertex들까지의 최단경로를 구한다. 
  2. 사이과정은 위의 문제들과 동일
  3. 가장 오래걸린 경로를 출력, 무한인 아닌 개수가 감염된 컴퓨터 수이다.      
  (경로가 없다면 감염될 수 없고, 동시에 진행되기 때문에 최단경로가 가장 긴 컴퓨터의 경로가 감염되기까지 걸리는 시간과 같다.)

## 2211번 <네트워크 복구>
> + N개의 컴퓨터로 구성된 네트워크가 존재
> + 회선을 통해 연결
> + 보안 시스템을 위헤 한대의 슈퍼컴퓨터에만 보안 시스템 설치
> + 네트워크 복구 조건
> 1. 서로 다른 두 컴퓨터 간에 통신이 가능하도록 최소 개수의 회선만을 복구
> 2. 슈퍼컴퓨터가 다른 컴퓨터들과 통신하는데 걸리는 최소 시간이 원래의 네트워크에서 통신하는데 거리는 시간보다 커져서는 안된다.
> + N : 컴퓨터 수, M: 회선수 , A ,B C :A컴퓨터와 B컴퓨터간의 통신 시간 C
> + 1번은 보안 시스템을 설치할 슈퍼컴퓨터
> + 출력 : 복귀한 회선 개수 와 회선

  ### 풀이과정
  1. 양방향이여서 회선에 대한 정보들을 저장(시작컴퓨터, 끝컴퓨터, 통신시간)
  2. 슈퍼컴퓨터가 기준이기 때문에 이를 시작점으로 실행
  3. 네트워크 복구조건 2번 때문에 슈퍼컴퓨터가 다른 컴퓨터들로 향하는 최소 통신시간 경로만을 이용가능
  4. 최소 통신시간을 구할 때, 최소 통신시간이 업데이트 될 때마다 그 경로를 기억하고 있어야한다.      
  (예시, 1-4가 최소였다가 1-2-4가 최소가 되면 2-4를 기억하면 된다.)
  5. 경로들을 저장한 사이즈와 경로들을 출력
